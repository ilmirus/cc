Сегодня я хочу попробовать кое-что новое. То, что я не делал последние несколько лет (как минимум, пару лет). Я хочу попробовать попрограммировать для удовольствия. Не потому, что что-то там горит и надо срочно что-то сделать, не потому, что если я не посижу в отладчике, то день пройдёт зря и я буду себя чувствовать отвратительно, не потому что надо. А потому что хочу. Назовём это recreational programming.

Что я буду программировать? Я компиляторщик и написание компиляторов - это не только моя работа. В первую очередь, мне это по приколу. Поэтому буду писать компилятор. Кроме того, иметь под рукой игрушечный компилятор, на котором можно пробовать идеи - это моя давняя мечта. Какой компилятор, какого языка? Сей, разумеется! На сях? Не-а. На плюсах, для начала.

Почему я говорю для начала? Увидите. Небольшой спойлер - навряд ли всё закончится написанием компилятора. Как я уже сказал, я хочу обкатать некоторые идеи. И я начну обкатывать их с самого начала, иначе это будет просто ещё одна работа. Какие идеи? Увидите. Но если коротко, то мне не надо думать над тем, как это будут поддерживать через пару лет мои коллеги, а это открывает двери для того, что нельзя в команде. Правда, документировать я всё равно буду, потому что я всё равно буду к этому проекту возвращаться и документация будет отправной точкой в этом случае. И навряд ли это закончится написанием одного компилятора.

Правда, некоторые правила придётся выставить. Первое - не пытаться покрыть всё. Си 89 для начала будет достаточно. Второе - не использовать свою кодогенерацию*. Вместо этого использовать что-то простое, типа QBE. Те, кто подумать про LLVM могут поцеловать мой блестящий зад - я не буду использовать что-то, что только скачивается полчаса. Вместо этого лучше буду использовать то, в чём я могу разобраться целиком. Это, кстати, третье правило - использовать только те third-party штуки, в которых я могу разобраться целиком. Ибо, опять-таки, не будет коллег, на которых можно будет спихнуть (делегировать) задачи по отладке. Четвёртое правило - использовать готовые куски кода и нейронки запрещается**.

* здесь я имею в виду кодогенерацию бинарного кода. На кодогенерацию сырцов запрет не распространяется.
** Не относится к тестам. Тесты можно копипастить из других компиляторов.

Теперь начальные условия. ГЦЦ текущей версии. Плюсы - те, которые поддерживает ГЦЦ. В качестве системы сборки - мейк, для начала, а потом посмотрим - возможно, я напишу свою, заточенную конкретно под этот проект just 4 lulz.

Вроде всё. А нет, ещё как я буду программировать. Компилятор можно писать разными способами. Первый - это реализовать самую базовую функциональность, чтобы что-то типа
```
int main(int argc, const char **args) {
	return 0;
}
```
компилировалось и генерировало нужный бинарник, а затем расширять. Но это не мой путь. Я предпочитаю сначала полностью реализовать какую-нибудь стадию, перед тем, как переходить к следующей. И так как одна из целей - это проверка идей, то каждая стадия будет переписываться и не раз. Я, скорее всего, буду не раз возвращаться к исходной точке и пытаться сделать это по-другому.

Я не знаю и не могу предположить заранее, сколько времени это у меня займёт. Но надеюсь, мне удастся вспомнить, почему я стал компиляторщиком и ощутить полёт мысли, который заставит вскакивать посреди ночи только чтобы это проверить.
