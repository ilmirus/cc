# Инлайнинг

Вот и настал тот момент, когда мне пришлось вернуть инлайнинг. Я поддерживал ключевые слова и каждое правило завершалось
```
(?![_0-9a-zA-Z])
```
Что означает, что после матча не должно быть этих символов (negative lookahead). То есть, была вереница правил типа
```
Auto = auto(?![_0-9a-zA-Z])
Break = break(?![_0-9a-zA-Z])
Case = case(?![_0-9a-zA-Z])
Char = char(?![_0-9a-zA-Z])
```

Разумеется, эти суффиксы желательно вынести в отдельное правило и его же использовать в правиле для идентификаторов.
Например,
```
inline identifierRest = [_a-zA-Z0-9]
inline notId = (?!identifierRest)

Identifier = [_a-zA-Z] identifierRest*
```
Я добавил модификатор `inline`, чтобы отличать эти правила от правил для пробельных символов
```
Whitespace = singleLineComment | multiLineComment | whitespace
singleLineComment = //[^\n]*
multiLineComment = /\*[\s\S]*?(\*/|$) { if (!it.ends_with("*/")) throw std::runtime_error("Unclosed multiline comment"); }
whitespace = [ \t\r\f\v]+
```
Последние присутствуют в матче, тогда как новые правила должны встраиваться в места использования.

# Контекстно-зависимые правила

Все предыдущие примеры были контекстно-независимыми, то есть, токен матчился вне зависимости от его положения в файле.
Если регекс сматчил токен, он появлялся в результирующем векторе.

Однако, си, несмотря на кажужуюся простоту, содержат один пример контектно-зависимого токена. Раздел 6.1.7 стандарта
определяет токет `HeaderName`. Он может появиться только после директивы `#include`. Для поддержки этого токена надо
как-то либо определять предыдущие токены, либо вводить контексты.

Первое решение противоречит разделению бизнес логики и бойлерплейта.

Второе можно реализовать разными способами. Например, flex использует состояния. Но я не хочу их использовать, потому
что это ведёт к дублированию правила для `Whitespace` (для каждого состояния надо отдельно поддерживать пробельные
символы).

Поэтому я решил использовать guard conditions. Например, `HeaderName` будет выглядеть как
```
HeaderName if (state == kAfterInclude) = "[^\n]*"|<[^\n]*>
```

Но тут возникает первая проблема. Что делать, если регексп сматчился, а условие невыполнено? В текущей реализации
матчинг завершится. Значит, надо матчить после того, как условие выполнится. Что значит, огромный регекс придётся
разделить.