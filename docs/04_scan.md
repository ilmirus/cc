## Незакрытые комменты

> Но в будущем надо будет проверять на незакрытость многострочных комментариев.
> И вся простота обработки матчей уйдёт, ибо придётся отойти от шаблона.

> Очевидно, что в таком случае вложенные правила не могут содержать действий (пока).

И вот этот момент настал - пришло время поддержать незакрытые комменты.

Казалось бы, чего сложного - просто надо поддержать действия в подправилах, к примеру
```
multiLineComment = /\*[\s\S]*?(\*/|$) { if (!it.ends_with("*/")) throw std::runtime_error("Unclosed multiline comment"); }
```
Однако, тогда перестаёт работать схема встраивания - это действие будет распространяться на все виды пробельных символов
и комментариев.

Значит, необходим другой вариант - а именно, нужно разбить регекс `((?://.*?(?=\n|$)|/\*[\s\S]*?(?:\*/|$)|[ \t\r\f\v]+)+)`
на отдельные элементы и матчить их поотдельности. Но тип энама выбирать тот, что был для родительского правила.

И так как последовательность правил в файле имеет значение, то подправила нужно придвинуть поближе к родительскому,
а не оставлять в хвосте, как раньше.
```
Whitespace = singleLineComment | multiLineComment | whitespace
singleLineComment = //.*?(?=\n|$)
multiLineComment = /\*[\s\S]*?(\*/|$) { if (!it.ends_with("*/")) throw std::runtime_error("Unclosed multiline comment"); }
whitespace = [ \t\r\f\v]+
```
Родительский регекс больше генерироваться не будет, а вместо него будет три регекса. Сгенерированный матч будет содержать
следующие строки
```
} else if(match[5].matched) { // singleLineComment
  token.kind = PPToken::kWhitespace;
} else if(match[6].matched) { // multiLineComment
  const auto &it = match.str(0);
  { if (!it.ends_with("*/")) throw std::runtime_error("Unclosed multiline comment"); }
  token.kind = PPToken::kWhitespace;
} else if(match[7].matched) { // whitespace
  token.kind = PPToken::kWhitespace;
```
То есть, больше не будет соответствия один к одному элементов энама и ветвей в матче (но должно быть соответствие один к одиному
между регексами и ветвями в матче). Но это не проблема, так как код генерируется и когодогенератор автоматически генерирует
правильные индексы.

Таким образом, мне удалось избавиться от ограничения на отсутствие действий в подправилах. Вместо этого у меня теперь другое
ограничение - родительское правило может быть только выбором. То есть, в паттерне могут быть только имена подправил, разделёные
`|`. При этом в родительском правиле могут быть действия - они копируются в подправила.

Вы могли заметить, что это ограничение меняет логику - если раньше пробельные токены не дублировались, когда пробелы чередовались
с комментариями, то теперь они будут дублироваться. Можно, конечно, усложнить логику кодогенерации и бойлерплейта, чтобы
поддержать эту выколотую точку. Но я думаю, что проще подобное обработать дальше - как я делаю в функции `skip_ws`, которая
пропускает все пробельные символы, а но поодиночке. Аналогично я буду пропускать все пробельные токены. Ибо при парсинге -
превращении потока токенов в синтаксическое дерево - они все игнорируются. Как и при макроподстановках.

Вполне возможно, их можно вообще не добавлять в поток токенов - мне надо это обдумать.

Пока что встраивание ушло, но обещало вернуться - когда я буду поддерживать escape-sequences, то для читаемости
и уменьшения дублирования их надо будет вынести в подправила. К счастью, код встраивания остался в гите и я его могу в любой
момент оттуда достать.

## Расширяемость

Точно так же, как и программа, и её архитектура меняются со временем, с поступлением новых требований, так же и наш DSL
меняется. В этом преимущество своих DSL - их можно менять под себя относительно малой кровью, не заморачиваясь с процессом
принятия предложений в работу у языков общего назначения и не ожидая нескольких лет, пока это предложение реализуют. Да,
некоторые реализации поддерживают расширение с помощью компиляторных плагинов, но не все.

Справедливости ради, есть языки,
которые можно расширять с помощью полноценных макросов - лиспы. Но их расширения должны использовать лисповый синтаксис.
Только racket поддерживает создание своих DSL с нелисповым синтаксисом.

Но мой пример показывает, что можно расширять почти
любой язык с помощью кодогенерации, если система сборки это поддерживает. Поэтому я выбрал make в самом начале - мне совсем
не улыбается писать плагин для гредла или для мавена. Для make мне ничего не нужно писать дополнительно.
