Перед тем, как начнём, если вы хотите следовать моим шагам, рекомендую скачать сишный стандарт по ссылке https://web.archive.org/web/20200909074736if_/https://www.pdf-archive.com/2014/10/02/ansi-iso-9899-1990-1/ansi-iso-9899-1990-1.pdf 

В разделе 5.1.1.2 расписаны шаги трансляции. Там всё расписано максимально непонятно для обычного человека, поэтому, если коротко, то трансляция состоит из следующих шагов

1. Сырцы токенизируются в токены препроцессора.
2. Директивы препроцессора исполняются, инклюды токенизируются, директивы в них исполняются и всё встраивается в текущую единицу трансляции.
3. Токены препроцессора транслируются в токены.
4. Поток токенов парсится, анализируется и транслируется в бинарные объекты.
5. Бинарные объекты линкуются линкером.

Я опустил некоторые шаги, например, замену комментариев на пробелы, но они будут покрыты, не беспокойтесь. 
Триграммы (5.2.1.1) теперь не используются, поэтому я их буду игнорировать. 
Раздел 5.2.1 описывает минимальный набор символов, которые нужно будет поддержать. 
Юникод может быть поддержан, но не обязателен, поэтому я пока юникод буду игнорировать.

Можно переходить к реализации. 
Начнём, разумеется, с первого шага. 
Раздел 6.1 описывает, что представляют собой токены и токены препроцессора. 
Последние вот они

```
preprocessing-token
	header-name
	identifier
	pp-number
	character-constant
	string-literal
	operator
	punctuator
	each non-white-space character that cannot be one of the above
```

В плюсах это будет выглядеть как
```
struct PPToken {
	Locus locus;

	enum {
		kWhitespace,
		kNewLine,
		kHash,
		kHashHash,
		kHeaderName,
		kIdentifier,
		kPPNumber,
		kCharacterConstant,
		kStringLiteral,
		kOperator,
		kPunctuator,
		kNonWhiteSpace
	} kind;

	std::string value;
};
```
в рамках препроцессора нам не важны точные значения констант, поэтому все токены это просто строки с тегом и их координатами в сырце. 
Вообще, `Locus` объявлен как
```
struct Locus {
	std::string file;
	int row, column;
};
```
Конкретно сейчас он нам не особо нужен, но будет нужен для фазы анализа, чтобы кидать ошибки и варнинги. 
Плюс, я добавил пробельные символы и новые строки, которые важны для препроцессора.

`#` и `##` используются только для препроцессора и поэтому проще для последующих шагов их обрабатывать явно.

Те символы, которые не определены в стандарте, например, `@`, необходимо обрабатывать, не кидая ошибки (пока). 
Потому что они могут быть внутри директив `#if 0 ... #endif`.

Почему я использую тяжёлый `std::string` вместо легковесного `std::string_view`? 
Потому что авторы LLVM - ленивые пидорасы, из-за которых конкатенация `std::string` и `std::string_view` будет доступна только через пару лет, как и конкатенация двух `std::string_view` - https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2591r5.html. 
Из комментариев к ответу https://stackoverflow.com/questions/44636549/why-is-there-no-support-for-concatenating-stdstring-and-stdstring-view - 
"Wow. Just wow! This seems to be the worst possible reason for leaving something out. 
The standard is supposed to be for the good of the language, not for any particular implementation."


