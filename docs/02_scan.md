# Лексер, часть 2

## Препрепроцессор

В прошлый раз я разделил логику на описание того, что матчить и вторую, куда я не хочу заглядывать, несмотря на то, что она очевидна.
Потому что вторая часть нужна только для того, чтобы первая часть заработала.
Это чистый бойлерплейт, в котором, однако, довольно-таки просто допустить багу.
Плюсы, к сожалению, довольно часто требуют подобного бойлерплейта.
И об одном из подобных случаях я хочу рассказать.

Но для начала описание задачи.
Как вы, наверное, знаете, Си и плюсы поддерживают перенос строки - `\\\n` и мне, соответственно, тоже надо его поддержать.
Но вот беда - этот перенос строки _не разделяет токены_.
То есть, следующий код
```
foo\
bar
```
это один токен - идентификатор `foobar`.
То есть, не получится написать регексп, чтобы поддержать все подобные случаи.
Ну или он будет совсем нечитаемым.

К счастью, регекспы в плюсах (и вообще плюсы в целом) следуют философии обобщённого программирования, которую я больше нигде не встречал.
Они используют итераторы вместо конкретных типов.
Что это значит для текущей задачи?
В отличие от других языков, плюсовым регекспам насрать, что им подают на вход - стандартную строку или что-то пользовательское.
Причина, разумеется, в том, что в мире есть куча фреймворков и библиотек, в которых определены свои типы строк и не поддерживать их нельзя.
Ссылку на то, как подобные типы в LLVM тормозят развитие языка, я уже кидал, повторяться не буду.

Таким образом, мне достаточно определить свой тип строк, создать тип итератора и его подать на вход регекспам.
Я, конечно, люблю плюсы за их гибкость, но мне почему-то кажется, что тип итератора можно было бы описать гораздо проще.
```
    struct Iterator {
        using iterator_category = std::bidirectional_iterator_tag;
        using value_type = char;
        using difference_type = std::ptrdiff_t;
        using pointer = char*;
        using reference = char&;

        char *ptr;

        char& operator*() const {
            if (is_line_splice()) return *(ptr + 2);
            else                  return *ptr;
        }

        bool is_line_splice() const {
            return *ptr == '\\' && *(ptr + 1) == '\n';
        }

        Iterator& operator++() {
            if (is_line_splice()) ptr += 3;
            else                  ++ptr;
            return *this;
        }

        Iterator& operator--() {
            if (*(ptr-1) == '\n' && *(ptr-2) == '\\') ptr -= 3;
            else                                      --ptr;
            return *this;
        }

        Iterator operator++(int) {
            Iterator temp = *this;
            ++(*this);
            return temp;
        }

        Iterator operator--(int) {
            Iterator temp = *this;
            --(*this);
            return temp;
        }

        Iterator& operator+=(difference_type diff) {
            if (diff > 0) {
                for (difference_type i = 0; i < diff; ++i) {
                    ++(*this);
                }
            } else {
                for (difference_type i = 0; i > diff; --i) {
                    --(*this);
                }
            }
            return *this;
        }

        bool operator==(const Iterator& other) const { return ptr == other.ptr; }
        bool operator!=(const Iterator& other) const { return ptr != other.ptr; }
    };
```
особенно после того, как знаешь, что в том же Котлине постфиксные инкремент и декремент выводятся из префиксных.

И да, не дай бог вам допустить ошибку в этом бойлерплейте - отладка может занять кучу времени.
Ну или можно спросить нейронку, поправить её, что с регекспами всё норм и бага в другом, выбеситься её твердолобостью, переключиться на другую нейронку, поправить её, что с регекспами всё норм, а бага где-то в итераторе, почуствовать себя идиотом, когда она тебе укажет, что ты забыл при копипасте инкремент заменить на декремент.
Я, разумеется, пошёл первым путём и отлаживал кишки плюсовой стдлибы.
Зуб даю, всё так и было!

Этот итератор завёрнул в ещё один бойлерплейт
```
// same as std::string, but ignores line splices
struct PPInput {
    std::string raw;

    struct Iterator { ... }

    Iterator begin() { return Iterator(raw.data()); }
    Iterator end() { return Iterator(raw.data() + raw.size()); }
};
```

Кстати про бойлерплейт. Так как мы поменяли входной тип регекспа, то надо поменить и логику обработки матчей. Вместо
```
    std::string initial = input;

    while (std::regex_search(input, match, patterns)) {

        ...


        input = input.substr(match.position() + match.length());
        locus = calculate_locus(file, initial, input);
    }
```
Теперь будет
```
    PPInput pp_input { input };
    auto iter = pp_input.begin(), end = pp_input.end();

    while (std::regex_search(iter, end, match, patterns)) {

        ...

        iter += match.length();
        locus = calculate_locus(file, input, iter.ptr);
    }
```

На что только не пойдёшь, лишь бы код бизнес-логики был как можно больше отделён от бойлерплейта.
Но у меня уже есть идея, как ещё сильнее выделить бизнес-логику и, что важнее, уменьшить вероятность бага в бойлерплейте.

## Комментарии

Совсем короткая заметка.
В прошлый раз я говорил, что комментарии, а именно замена их на пробельные символы и объединение их с другими пробельными символами будет поддержана в своё время. Внимание, поддержка!
```
        "((?:"
            R"((?://.*?(?=\n|$))|)" // singleline-comment
            R"((?:/\*[\s\S]*?(?:\*/|\z))|)" // multiline-comment
            R"((?:[ \t\r\f\v]+))" // whitespace
        ")+)|"
```
Всё это дело отправляется в `PPToken::kWhitespace`.
Но в будущем надо будет проверять на незакрытость многострочных комментариев.
И вся простота обработки матчей уйдёт, ибо придётся отойти от шаблона
```
        } else if (match[PPToken::kStringLiteral].matched) {
            if (!match.str(0).ends_with("\"")) throw std::runtime_error("Unclosed string literal");
            token.kind = PPToken::kStringLiteral;
        } else if (match[PPToken::kIdentifier].matched) {
            token.kind = PPToken::kIdentifier;
```

Но пусть будущий я будет решать эту проблему.